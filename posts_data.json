[
    {
        "id": "mitchellh_vouch",
        "name": "vouch",
        "github_url": "https://github.com/mitchellh/vouch",
        "script_text": "Vouch is a community trust management system that allows projects to enforce explicit vouches for participation. The implementation is generic and can be integrated into any project on any code forge, with built-in GitHub integration through GitHub Actions and a command-line interface.\n\nVouch maintains a flat file of vouched and denounced users, which can be easily parsed using standard POSIX tools and any programming language. Projects can also configure Vouch to read other projects' trust lists, creating a web of trust across the ecosystem. This way, users proven trustworthy in one project can automatically be assumed trustworthy in another.\n\nVouch is an experimental system currently in use by the Ghostty project, aiming to address the challenge of low-quality contributions enabled by AI tools, while preserving the trust-based nature of open-source collaboration."
    },
    {
        "id": "pydantic_monty",
        "name": "monty",
        "github_url": "https://github.com/pydantic/monty",
        "script_text": "Monty is a minimal, secure Python interpreter written in Rust for use by AI. It avoids the complexity and overhead of container-based sandboxes, enabling AI agents to run Python code with startup times measured in microseconds, not milliseconds.\n\nMonty provides a carefully curated subset of Python functionality, with complete control over the host environment. It supports type-checking, allows calling host functions, and can be quickly snapshotted and resumed. Monty's performance is similar to CPython, and it can be used from Rust, Python, or JavaScript.\n\nThe primary use case for Monty is to enable AI agents to safely execute code generated by large language models, without the cost and latency of full container-based isolation."
    },
    {
        "id": "villagesql_villagesql_server",
        "name": "villagesql-server",
        "github_url": "https://github.com/villagesql/villagesql-server",
        "script_text": "VillageSQL Server is an open-source fork of MySQL 8.4.6 that introduces the VillageSQL Extension Framework (VEF). VEF enables developers to create custom data types and functions while maintaining MySQL 8.4 compatibility. \n\nThe key features include the ability to define domain-specific data types, implement high-performance logic within the database, and seamlessly integrate with existing MySQL 8.4 applications and tools. \n\nVillageSQL Server is currently in alpha and intended for development and testing purposes. It provides a new path for MySQL in the agentic AI era, allowing database engineers to extend the core functionality of their MySQL-based applications."
    },
    {
        "id": "tonystef_grov",
        "name": "Grov",
        "github_url": "https://github.com/TonyStef/Grov",
        "script_text": "Grov automatically captures the context from your private AI sessions and syncs it to a shared team memory. It injects relevant memories across developers and future sessions, saving tokens and time spent on tasks. Your team's AI agents are no longer learning in silos - when one dev's AI figures something out, every dev's AI knows it. Grov measures a significant drop in task times, from 10+ minutes to 1-2 minutes, when team context is available. Grov is the collective AI memory for engineering teams."
    },
    {
        "id": "christopherkarani_wax",
        "name": "Wax",
        "github_url": "https://github.com/christopherkarani/Wax",
        "script_text": "Introducing Wax: a memory layer for on-device AI agents on iOS and macOS. Wax replaces complex, distributed RAG pipelines with a single, self-contained file that provides document storage, semantic search, and automatic token budgeting - all powered by Apple Silicon acceleration.\n\nWax's hybrid retrieval engine fuses BM25 keyword search with HNSW vector similarity, ensuring your agents always retrieve the most relevant context, even when the phrasing differs. Powered by MiniLM embeddings running locally, Wax never makes external API calls, keeping your users' data private and secure.\n\nDesigned for crash-safety and ease-of-use, Wax's portable file format allows you to seamlessly backup, sync, and move your agents' memory. Equip your on-device AI apps with a robust, serverless memory layer that just works."
    },
    {
        "id": "cranot_roam_code",
        "name": "roam-code",
        "github_url": "https://github.com/Cranot/roam-code",
        "script_text": "Roam Code is an architectural intelligence layer for AI coding agents. It pre-indexes your codebase into a semantic graph, providing structural understanding beyond basic grep and file reading. Roam offers 94 commands across 26 languages, allowing agents to comprehend, govern, and refactor codebases without syntax errors. It maps vulnerability paths, orchestrates multi-agent workflows, and simulates refactoring outcomes - all locally, with zero API keys. Roam replaces the inefficient cycles of exploring codebases with a single graph query, giving your agents the architectural context they need to work efficiently. Best for developers and DevOps teams building intelligent coding assistants and automation tools."
    },
    {
        "id": "n_e_pg_typesafe",
        "name": "pg-typesafe",
        "github_url": "https://github.com/n-e/pg-typesafe",
        "script_text": "pg-typesafe generates TypeScript types for PostgreSQL queries. It does so with no runtime dependencies and zero additional verbosity.\n\nHere's a query with pg-typesafe:\n\n```ts\nconst { rows } = client.query(\n  \"select id, name, last_modified from tbl where id = $1\",\n  [42],\n);\n```\n\nThis query looks the same as a normal pg query, but is fully typed. The parameter is required and must be a number, and the `rows` type is `{ id:number; name:string; last_modified: Date }[]`.\n\nTo get started, install pg-typesafe, run it once to generate the type definitions, and then cast your `Pool` to the generated `TypesafePool` type. pg-typesafe can only type queries where the SQL is a constant, but this helps avoid SQL injection and improves performance."
    },
    {
        "id": "taleshape_com_shaper",
        "name": "shaper",
        "github_url": "https://github.com/taleshape-com/shaper",
        "script_text": "Visualize and share your data, all in SQL, powered by DuckDB. Shaper is an open-source, SQL-driven data dashboard solution that allows you to build analytics dashboards simply by writing SQL. With features like white-labeling, row-level security, and the ability to embed without iframes, Shaper is designed for both business intelligence and embedded analytics use cases. Easily generate reports in various formats, set up scheduled alerts, and share password-protected links. Shaper's SQL-first and AI-ready approach makes it a powerful tool for data-driven decision making."
    },
    {
        "id": "seflless_slowmo",
        "name": "slowmo",
        "github_url": "https://github.com/seflless/slowmo",
        "script_text": "Introducing slowmo - a powerful tool that allows you to control the timing of any web content. Slow down, pause, or speed up animations, videos, and more with just a few lines of code. This innovative library uses the Web Animations API to seamlessly integrate with existing web technologies, making it a versatile solution for developers.\n\nWhether you're debugging complex animations, studying captivating demos, or adjusting game difficulty, slowmo puts you in control. The intuitive API and optional dial component make it easy to fine-tune the pace of your content. Plus, the Chrome extension coming soon will let you control any website's animations without writing a single line of code.\n\nUnlock new possibilities for your web projects with slowmo - the ultimate tool for mastering time."
    },
    {
        "id": "millionco_react_doctor",
        "name": "react-doctor",
        "github_url": "https://github.com/millionco/react-doctor",
        "script_text": "React Doctor is an innovative tool that helps developers diagnose and fix issues in their React code. Using static code analysis, it identifies common problems, such as inefficient rendering, incorrect state management, and accessibility concerns. \n\nThe tool provides detailed insights and actionable recommendations, empowering developers to optimize their React applications. Its unique approach combines automated analysis with human-readable explanations, making it easier for developers to understand and address the identified problems.\n\nReact Doctor is particularly useful for teams working on complex React projects, as it helps them maintain code quality and performance. By integrating this tool into their development workflow, developers can catch and resolve issues early, reducing technical debt and improving the overall user experience."
    },
    {
        "id": "brendanhogan_hermitclaw",
        "name": "hermitclaw",
        "github_url": "https://github.com/brendanhogan/hermitclaw",
        "script_text": "HermitClaw is a unique AI system that generates its own research and creative content, continuously exploring topics of interest. Unlike typical AI assistants that wait for prompts, HermitClaw actively gathers information, writes reports, and builds a personalized knowledge base over time.\n\nThe project leverages a generative language model, a memory system inspired by neuroscience, and a dreaming cycle to consolidate experiences. HermitClaw lives in a pixel-art environment, wandering between a desk, bookshelf, and bed as it processes data and generates new ideas.\n\nUsers can interact with HermitClaw, provide it with files to study, and observe its autonomous exploration. This unattended AI agent offers a fascinating window into the emergence of a unique cognitive process."
    },
    {
        "id": "ladybugdb_ladybug",
        "name": "ladybug",
        "github_url": "https://github.com/LadybugDB/ladybug",
        "script_text": "LadybugDB is an embedded graph database optimized for query speed and scalability. Its flexible property graph data model and Cypher query language make it well-suited for complex analytical workloads. \n\nLadybug features native full-text search, vector indices, columnar storage, and factorized query processing for efficient performance. Its serializable ACID transactions and WebAssembly bindings enable secure integration into applications.\n\nLadybug's core technology includes novel join algorithms, multi-core parallelism, and a columnar sparse row-based adjacency list. This unique architecture provides a powerful, embeddable graph database solution for developers.\n\nWhether you're working with large, interconnected datasets or building real-time applications, Ladybug's speed and scalability make it an excellent choice for your next project."
    }
]